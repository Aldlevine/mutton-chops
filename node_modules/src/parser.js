module.exports = Parser;

var HtmlParser = require('htmlparser2')
  , Utils = require('src/utils')
  , CharBuf = require('src/char-buf')
  , MCChunk = require('src/mc-chunk')
  , stream = require('stream')
  , util = require('util')
;

/**
 * The document parser
 * @class Parser
 * @param {Object|Function} [opts] The parser options
 * @param {Function} done The callback once parsing is complete
 */
var Parser = function Parser(opts)
{
  if(!(this instanceof Parser))
    return new Parser(opts);
    
  stream.Transform.call(this);

  var self = this
    , opts = Utils.defaults({}, opts)
  ;

  this._readableState.objectMode = true;
  this._writableState.objectMode = false;
  this.htmlparser = new HtmlParser.Parser(this.DomHandler());
}

util.inherits(Parser, stream.Transform);


/**
 * Handles the transform stream
 * @function Parser#_transform
 * @param  {Buffer} chunk - The data buffer
 * @param  {string} enc - The data encoding
 * @param  {Function} fn - The callback function
 * @return {Stream} A readable stream
 */
Parser.prototype._transform = function(chunk, enc, fn)
{
  this.htmlparser.write(chunk);
  fn();
}

Parser.prototype.end = function()
{
  this.htmlparser.end();
  this.push(null);
}

/**
 * Custom DOM Handler
 * @function Parser#DomHandler
 * @returns {Object} The DOM handler
 */
Parser.prototype.DomHandler = function ()
{
  var self = this
    , handler = new HtmlParser.DomHandler(function(err, dom){
        if(dom != null)
          self.push(dom);
      });
  ;

  handler.ontext = function(text)
  {
    this._addDomElement({
      data: self.parseText(text),
      type: HtmlParser.ElementType.text
    });
  }

  handler.onopentag = function(name, attribs)
  {
    for( var attrName in attribs )
    {
      attribs[attrName] = self.parseText(attribs[attrName]);
    }

    var element = {
    	type: name === "script" ? HtmlParser.ElementType.Script : name === "style" ? HtmlParser.ElementType.Style : HtmlParser.ElementType.Tag,
    	name: name,
    	attribs: attribs,
    	children: []
    };

    this._addDomElement(element);

    this._tagStack.push(element);
  }

  return handler;
}


/**
 * Parses a string of text into an array of strings and MCChunks
 * @function Parser#parseText
 * @param {string} str - The text to parse
 * @return {Object[]} An array of strings and MCChunks
 */
Parser.prototype.parseText = function (str) {
  var charBuf = new CharBuf(str)
    , isInMC = false
    , chunkCur = ''
    , chunks = []
  ;

  while(charBuf.consume())
  {
    if(!isInMC)
    {
      if( charBuf.charCur == '{' && charBuf.charNxt[0] == '{' )
      {
        charBuf.consume();
        isInMC = true;
        if(chunkCur.length) chunks.push(chunkCur);
        chunkCur = '';
        continue;
      }
      else
      {
        chunkCur += charBuf.charCur;
      }
    }
    else
    {
      if( charBuf.charCur == '}' && charBuf.charNxt[0] == '}' )
      {
        charBuf.consume();
        isInMC = false;
        chunks.push( new MCChunk(chunkCur) );
        chunkCur = '';
      }
      else
      {
        chunkCur += charBuf.charCur;
      }
    }
  }
  if( chunkCur.length ) chunks.push(chunkCur);
  return chunks;
};
